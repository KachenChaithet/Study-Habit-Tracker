import {
  require_react
} from "./chunk-BQYK6RGN.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-hot-toast/headless/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var N = (e) => typeof e == "function";
var D = (e, t) => N(e) ? e(t) : e;
var V = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})();
var j = 20;
var h = "default";
var v = (e, t) => {
  let { toastLimit: s } = e.settings;
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, s) };
    case 1:
      return { ...e, toasts: e.toasts.map((o) => o.id === t.toast.id ? { ...o, ...t.toast } : o) };
    case 2:
      let { toast: r } = t;
      return v(e, { type: e.toasts.find((o) => o.id === r.id) ? 1 : 0, toast: r });
    case 3:
      let { toastId: a } = t;
      return { ...e, toasts: e.toasts.map((o) => o.id === a || a === void 0 ? { ...o, dismissed: true, visible: false } : o) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((o) => o.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let T = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((o) => ({ ...o, pauseDuration: o.pauseDuration + T })) };
  }
};
var O = [];
var I = { toasts: [], pausedAt: void 0, settings: { toastLimit: j } };
var l = {};
var M = (e, t = h) => {
  l[t] = v(l[t] || I, e), O.forEach(([s, r]) => {
    s === t && r(l[t]);
  });
};
var P = (e) => Object.keys(l).forEach((t) => M(e, t));
var U = (e) => Object.keys(l).find((t) => l[t].toasts.some((s) => s.id === e));
var f = (e = h) => (t) => {
  M(t, e);
};
var Q = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 };
var x = (e = {}, t = h) => {
  let [s, r] = (0, import_react.useState)(l[t] || I), a = (0, import_react.useRef)(l[t]);
  (0, import_react.useEffect)(() => (a.current !== l[t] && r(l[t]), O.push([t, r]), () => {
    let o = O.findIndex(([p]) => p === t);
    o > -1 && O.splice(o, 1);
  }), [t]);
  let T = s.toasts.map((o) => {
    var p, A, y;
    return { ...e, ...e[o.type], ...o, removeDelay: o.removeDelay || ((p = e[o.type]) == null ? void 0 : p.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: o.duration || ((A = e[o.type]) == null ? void 0 : A.duration) || (e == null ? void 0 : e.duration) || Q[o.type], style: { ...e.style, ...(y = e[o.type]) == null ? void 0 : y.style, ...o.style } };
  });
  return { ...s, toasts: T };
};
var B = (e, t = "blank", s) => ({ createdAt: Date.now(), visible: true, dismissed: false, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...s, id: (s == null ? void 0 : s.id) || V() });
var S = (e) => (t, s) => {
  let r = B(t, e, s);
  return f(r.toasterId || U(r.id))({ type: 2, toast: r }), r.id;
};
var n = (e, t) => S("blank")(e, t);
n.error = S("error");
n.success = S("success");
n.loading = S("loading");
n.custom = S("custom");
n.dismiss = (e, t) => {
  let s = { type: 3, toastId: e };
  t ? f(t)(s) : P(s);
};
n.dismissAll = (e) => n.dismiss(void 0, e);
n.remove = (e, t) => {
  let s = { type: 4, toastId: e };
  t ? f(t)(s) : P(s);
};
n.removeAll = (e) => n.remove(void 0, e);
n.promise = (e, t, s) => {
  let r = n.loading(t.loading, { ...s, ...s == null ? void 0 : s.loading });
  return typeof e == "function" && (e = e()), e.then((a) => {
    let T = t.success ? D(t.success, a) : void 0;
    return T ? n.success(T, { id: r, ...s, ...s == null ? void 0 : s.success }) : n.dismiss(r), a;
  }).catch((a) => {
    let T = t.error ? D(t.error, a) : void 0;
    T ? n.error(T, { id: r, ...s, ...s == null ? void 0 : s.error }) : n.dismiss(r);
  }), e;
};
var X = 1e3;
var q = (e, t = "default") => {
  let { toasts: s, pausedAt: r } = x(e, t), a = (0, import_react2.useRef)(/* @__PURE__ */ new Map()).current, T = (0, import_react2.useCallback)((i, c = X) => {
    if (a.has(i)) return;
    let u = setTimeout(() => {
      a.delete(i), o({ type: 4, toastId: i });
    }, c);
    a.set(i, u);
  }, []);
  (0, import_react2.useEffect)(() => {
    if (r) return;
    let i = Date.now(), c = s.map((u) => {
      if (u.duration === 1 / 0) return;
      let g = (u.duration || 0) + u.pauseDuration - (i - u.createdAt);
      if (g < 0) {
        u.visible && n.dismiss(u.id);
        return;
      }
      return setTimeout(() => n.dismiss(u.id, t), g);
    });
    return () => {
      c.forEach((u) => u && clearTimeout(u));
    };
  }, [s, r, t]);
  let o = (0, import_react2.useCallback)(f(t), [t]), p = (0, import_react2.useCallback)(() => {
    o({ type: 5, time: Date.now() });
  }, [o]), A = (0, import_react2.useCallback)((i, c) => {
    o({ type: 1, toast: { id: i, height: c } });
  }, [o]), y = (0, import_react2.useCallback)(() => {
    r && o({ type: 6, time: Date.now() });
  }, [r, o]), k = (0, import_react2.useCallback)((i, c) => {
    let { reverseOrder: u = false, gutter: g = 8, defaultPosition: R } = c || {}, E = s.filter((d) => (d.position || R) === (i.position || R) && d.height), w = E.findIndex((d) => d.id === i.id), _ = E.filter((d, b) => b < w && d.visible).length;
    return E.filter((d) => d.visible).slice(...u ? [_ + 1] : [0, _]).reduce((d, b) => d + (b.height || 0) + g, 0);
  }, [s]);
  return (0, import_react2.useEffect)(() => {
    s.forEach((i) => {
      if (i.dismissed) T(i.id, i.removeDelay);
      else {
        let c = a.get(i.id);
        c && (clearTimeout(c), a.delete(i.id));
      }
    });
  }, [s, T]), { toasts: s, handlers: { updateHeight: A, startPause: p, endPause: y, calculateOffset: k } };
};
var Ae = n;
export {
  Ae as default,
  D as resolveValue,
  n as toast,
  q as useToaster,
  x as useToasterStore
};
//# sourceMappingURL=react-hot-toast_headless.js.map
